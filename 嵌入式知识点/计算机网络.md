## 1. 计算机网络体系架构

### 1.1 OSI的体系结构

`1.物理层	2.数据链路层	3.网络层	4.运输层	5.会话层	6.表示层	7.应用层`

### 1.2 TCP/IP的体系架构

1.网络接口层	2.网际层 IP	3.运输层 TCP/UDP	4.应用层 DNS，HTTP等

### 1.3 五层协议的体系结构

`1.物理层	2.数据链路层	3.网络层	4.运输层	5.应用层`

![](D:\stm103\my_note\嵌入式知识点\计网体系结构.png)





## 2. TCP与UDP

### 2.1 TCP

**`TCP/IP`即传输控制协议，是`面向连接`的协议，发送数据前要先建立连接，TCP提供`可靠`的服务**

**通过TCP连接传输的数据`不会丢失`，`没有重复`，并且`按顺序`到达。（类似于打电话）**

支持点对点单播 不支持多播，广播

复杂，用于大多数应用 eg:万维网，电子邮件，文件传送等

### 2.2 UDP

**`UDP`它是属于TCP/IP协议族中的一种。是`无连接`的协议，发送数据前`不需要建立连接`，是`没有可靠性`的协议**

**不需要建立连接所以可以在在网络上以`任何可能的路径传输`，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。（类似于发微信）**

**支持点对点单播，多播，广播**

**简单，适用于很多应用 eg:多媒体应用等**

## 3. TCP的三次握手与四次挥手

### 3.1 三次握手

`第一次握手`：主机A 的 TCP 向 主机B `发出连接请求`报文段		

`第二次握手`：主机B 的 TCP 收到连接请求报文段后，如同意，则`发回确认`。

`第三次握手`：主机A 收到此报文段后向 主机B `给出确认`，其 ACK = 1，确认号 ack = y + 1。主机A 的 TCP 通知上层应用进程，连接已经建立。主机B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。



**三次握手的`目的`是建立`可靠`的通信信道，主要的目的就是`双方确认`自己与对方的`发送`与`接收`机能`正常`**



![](D:\stm103\my_note\嵌入式知识点\三次握手.png)



第一次握手：	发送者客户A什么都不能确认； 

​			  接受者服务器B确认了发送者客户A发送正常



第二次握手：	发送者客户A确认了：自己发送、接收正常，对方发送、接收正常；

​			  接受者服务器B确认了：自己接收正常，对方发送正常



第三次握手：	发送者客户A：自己发送、接收正常，对方发送、接收正常；

​			  接受者服务器B确认了：自己发送、接收正常，对方发送接收正常 



所以三次握手就能确认双发收发功能都正常，缺一不可。



### 3.2 四次挥手



**数据传输结束后，通信的双方都可释放连接**



`第一次挥手`：主机A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，`主动关闭` TCP 连接。

`第二次挥手`：主机B `发出确认`，发送一个ACK=1，确认号 ack = u+1，而这个报文段自己的序号 seq = v。TCP 服务器进程通知高层应用进程。从主机A 到主机B 这个方向的连接就释放了，TCP 连接处于CLOSE_WAIT状态。此时主机B 若发送数据，主机A 仍要接收。

`第三次挥手`：主机B 确认已经没有要向主机A 发送的数据，将`FIN置1`，其应用进程就`通知 TCP 释放连接`。

`第四次挥手`：主机A 收到连接释放报文段后，进入TIME_WAIT状态，`必须发出确认`。 在确认报文段中ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。主机B收到后，确认ack后，`变为CLOSED状态`，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。

![](D:\stm103\my_note\嵌入式知识点\四次挥手.png)





- **客户对服务器发送了关闭连接请求，**

- **服务器收到客户的关闭连接请求后，回复一个确认收到的消息**

- **服务器确定不再给客户发消息后，对客户发送，准备关闭连接的消息**

- **客户收到服务器要关闭连接的消息给服务器发送：已收到关闭连接的消息。**

  



## 4. MQTT

### 4.1 MQTT协议简介



MQTT协议全称是Message Queuing Telemetry Transport，翻译过来就是**`消息队列遥测传输协议`**



它是物联网常用的应用层协议，运行在TCP/IP中的应用层中，依赖TCP协议，具有非常高的可靠性



它是基于TCP协议的 <`客户端-服务器`> 模型`发布/订阅`主题消息的轻量级协议



在协议中主要有三种身份：`发布者`（Publisher）、`服务器`（Broker）以及`订阅者`（Subscriber）





### 4.2 服务器(Broker)功能



**是一个应用程序或一台设备，它一般为云服务器**

1.接受来自客户端的网络连接请求

2.接受客户端发布的应用消息

3.处理客户端的订阅和取消订阅请求

4.转发应用消息给符合条件的已订阅客户端（包括发布者自身）



### 4.3 客户端功能

1.发布消息给其它相关的客户端

2.订阅主题请求接收相关的应用消息

3.取消订阅主题请求移除接收应用消息

4.从服务端终止连接



### 4.4 消息主题

`主题`：MQTT`服务器`为每个连接的`客户端`（订阅者）添加一个**`标签`**，

该标签与服务器中的所有订阅相匹配，服务器会将消息**`转发`给与`标签相匹配`**的每个客户端（订阅者）



`订阅者`也是需要有`权限`才能订阅对应的主题，比如像阿里云中的，订阅者只能订阅同一个产品下的主题，

而不能跨产品订阅，这样子的处理就能达到信息的`安全性`以及多个订阅者能及时收到消息。



一个`主题`可以有`多个级别`，各个级别之间用`斜杠`字符分隔，例如/test 和 /test/test1/test2都 是有效的主题。



`发布者`与`订阅者`可以通过`主题名字`，一般为`UTF-8编码`（反正用英文字符串就不会错）的形式`发布和订阅`主题



每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间会有状态交互



`订阅`是基于会话之上，每个订阅中，都会包含一个`主题过滤器`，

`主题过滤器`是一个表达式，用于`标识`订阅相关的`一个或多个主题`，主题过滤器可以使用通配符

`订阅者`需要`指定`订阅的`主题名字`与`服务质量`（`QoS`），订阅者能订阅`多个`主题，也就能接收到多个发布者发布的消息



`发布者`也需要首先与服务器`建立会话`，并且指定发送的`主题名字`与`服务质量`，同时它也能向多个`不同`的主题`发送消息`。



### 4.5 服务质量(QoS)



MQTT的服务质量提供`3个等级`



#### 4.5.1 `QoS0`

最多`发送一次`消息，在消息发送出去后，`接收者`**不会发送回应**，`发送者`也**不会重发消息**

消息可能送达一次也可能根本没送达， 这个服务质量常用在`不重要`的消息传递中，因为即使消息丢了也没有太大关系。

#### 4.5.2 `QoS1`

最少发送一次消息(消息最少需要送达一次，也有可送达多次)

`QoS1`的`PUBLISH报文`的可变报头中包含一个报文标识符， 需要`PUBACK报文确认`。即需要接收者返回PUBACK`应答`报文。

#### 4.5.3 `QoS2`

这是`最高等级`的服务质量，消息`丢失`和`重复`都是`不可接受`的

使用这个服务质量等级会有`额外的开销`，这个等级常用于`支付`中，因为支付是必须有且仅有一次成功





## 5. LwIP

### 5.1 LwIP简介

LwIP全名：`Light weight IP`  轻量化的TCP/IP协议

LwIP的设计初衷是：用`少量`的`资源消耗`实现一个`较为完整`的`TCP/IP协议栈`

其中“`完整`”主要指的是`TCP协议`的完整性，实现的重点是在保持TCP协议主要功能的基础上`减少对RAM 的占用`。

LwIP既可以移植到`操作系统`上运行，也可以在`裸机`的情况下独立运行



### 5.2 主要特性

1. 支持ARP协议（以太网地址解析协议）。
2. 支持ICMP协议（控制报文协议），用于网络的调试与维护。
3. 支持IGMP协议（互联网组管理协议），可以实现多播数据的接收。
4. 支持UDP协议(用户数据报协议)。
5. 支持TCP协议(传输控制协议)，包括阻塞控制、RTT 估算、快速恢复和快速转发。
6. 支持PPP协议（点对点通信协议），支持PPPoE。
7. 支持DNS（域名解析）。
8. 支持DHCP协议，动态分配IP地址。
9. 支持IP协议，包括IPv4、IPv6协议，支持IP分片与重装功能，多网络接口下的数据包转发。
10. 支持SNMP协议（简单网络管理协议）。
11. 支持AUTOIP，自动IP地址配置。
12. 提供专门的内部回调接口(Raw API)，用于提高应用程序性能。
13. 提供可选择的Socket API、NETCONN API (在多线程情况下使用) 。



### 5.3 优点



1.**`资源开销低，即轻量化`**。

LwIP内核有自己的`内存管理策略`和`数据包管理策略`， 使得内核处理数据包的效率很高。

LwIP`高度可剪裁`，一切不需要的功能都可以通过宏编译选项去掉。

LwIP的流畅运行需要`40KB的代码ROM`和`几十KB的RAM`，这让它非常适合用在内存资源受限的嵌入式设备中。



2.**`支持的协议较为完整`**

几乎支持`TCP/IP`中所有常见的协议，这在嵌入式设备中早已够用。



3.**`实现了一些常见的应用程序`**：

DHCP客户端、DNS客户端、HTTP服务器、MQTT客户端、TFTP服务器、SNTP客户端等等。



4.**同时提供了三种编程接口**：

`RAW/Callback API`、`NETCONN API`、`Socket API`。



5.**`高度可移植`**

其`源代码`全部用`C语言`实现，用户可以很方便地实现`跨处理器`、`跨编译器`的移植。

它对内核中会使用到`操作系统功能`的地方进行了`抽象`，使用了一套自定义的`API`，用户可以通过自己实现这些API，从而实现`跨操作系统`的移植工作。



6.**`开源 免费`**



### 5.4 LwIP文件说明

[LwIP的项目主页](http://savannah.nongnu.org/projects/lwip/)

[LwIP的文件说明](https://doc.embedfire.com/net/lwip/zh/latest/doc/chapter2/chapter2.html)











