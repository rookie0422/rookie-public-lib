# C语言

## static 静态

### static 作用

用 static 修饰局部变量：使其变为静态存储方式(静态数据区)，那么这个局部变量在函数执行完成之后不会被释放，而是继续保留在内存中。

用 static 修饰全局变量：使其只在本文件内部有效，而其他文件不可连接或引用该变量。

用 static 修饰函数：对函数的连接方式产生影响，使得函数只在本文件内部有效，对其他文件是不可见的

### **static 全局变量**与**全局变量**区别

二者存储方式相同，都是 静态存储方式

非静态全局变量 作用域 整个程序

静态全局变量 作用域 定义该变量的源程序 

### static 函数与普通函数区别

静态函数的好处是，不用担心与其他文件的同名函数产生干扰，另外也是对函数本身的一种保护机制

非静态函数 作用域 整个程序

静态函数 作用域 定义该函数的源程序 

## const

### const 用法

用 const 修饰常量：定义时就初始化，以后不能更改。

用 const 修饰形参：func(const int a){};该形参在函数里不能改变。

用 const 修饰类成员函数：该函数对成员变量只能进行只读操作，就是 const 类成员函数是不能修改成员变量的数值的。



```c
const int a;
int const a; 			//前两个的作用是一样，a 是一个常整型数。
const int *a; 			//第三个意味着 a 是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。
int * const a; 			//第四个意思 a 是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。
int const * a const; 	//最后一个意味着 a 是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。

```

## volatile

### volatile 作用

用 volatile 修饰的变量说明是常变的，每次使用都要重新读取该变量在内存中的值

告诉编译器不需要优化该变量，每次获取到的该变量的值都是最新值

### volatile 常见用法

并行设备的硬件寄存器（如：状态寄存器）

一个中断服务子程序中会访问到的非自动变量

多线程应用中被几个任务共享的变量



## 内存分区

```c
int a0=1; 				//a0 ：全局初始化变量；生命周期为整个程序运行期间；作用域为所有文件；存储位置为 data 段。
static int a1;			//a1 ：全局静态未初始化变量；生命周期为整个程序运行期间；作用域为当前文件；储存位置为 BSS 段。
const static a2=0;		//a2 ：全局静态变量
extern int a3;			//a3 ：全局初始化变量；其他同 a0。

void fun(void)
{
 int a4;				//a4 ：局部变量；生命周期为 fun 函数运行期间；作用域为 fun 函数内部；储存位置为栈。
 volatile int a5;		//a5 ：局部易变变量；
 return;
}

```



## 指针





```c
int a；  			//一个整型数 a
int *a;				//一个指向整型数的指针 a	
int **a;			//一个指向指针的指针，a 指向的指针指向一个整型数
int a[10];			//一个有 10 个整型的数组； a 是指向数组首地址的指针
int *a [10];		//一个有 10 个指针的数组，该指针是指向一个整型数；
int a[10], *p=a;	//一个指向有 10 个整型数数组的指针
int (*a)(int)		//一个指向函数的指针，该函数有一个整型参数并返回一个整型数；
int( *a[10])(int)	//一个有 10 个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数

```



## typeof()

typeof 不是 c 语言本身的关键词或运算符  是 GCC 的一个扩展

**用某种已有的变量或函数的类型去定义新的变量的类型**

通常用在宏定义中 eg：

```c
typeof(var)
typeof(a[0])
typeof(int *)
typeof(fun())
```

可以看到，`typeof()` 中可以是任何有类型的东西，变量就是其本身的类型，函数是它返回值的类型。`typeof` 一般用于声明变量，eg:

```c
typeof(a) var;
```

从语法上来说，所有可以出现基本类型关键词的地方都可以使用 `typeof`，比如 `sizeof(typeof(a))` 这样的用法，虽然这里的 `typeof` 是多余的，不过它是符合语法的。

高级用法：

```c
int fun(int a);
typeof(fun) * fptr;    // int (*fptr)(int);

typeof(int *)a, b;     // int * a, * b;
typeof(int) * a, b;    // int * a, b;
```

可以看到，`typeof` 还可以用来定义函数指针等，且 `typeof(int *)a, b` 是定义了两个指针变量。

`typeof()` 是在编译时处理的，故**其中的表达式在运行时是不会被执行的**，比如 `typeof(fun())`，`fun()` 函数是不会被执行的，`typeof` 只是在编译时分析得到了 `fun()` 的返回值.

`typeof` 还有一些局限性，其中的变量是不能包含存储类说明符的，如 `static`、`extern` 这类都是不行的。


## 运算符
###    '!'

## 一些函数

在 `ctype.h` 中

1. `isalnum(c)`: 检查字符是否是字母或数字。如果字符是字母（包括大写和小写字母）或数字，则返回非零值，否则返回0。
2. `isalpha(c)`: 检查字符是否是字母。如果字符是字母（包括大写和小写字母），则返回非零值，否则返回0。
3. `iscntrl(c)`: 检查字符是否是控制字符。如果字符是ASCII控制字符（例如换行符、制表符等），则返回非零值，否则返回0。
4. `isdigit(c)`: 检查字符是否是数字。如果字符是数字（0-9之间的任何字符），则返回非零值，否则返回0。
5. `islower(c)`: 检查字符是否是小写字母。如果字符是小写字母，则返回非零值，否则返回0。
6. `isgraph(c)`: 检查字符是否是可打印字符，且不是空格。如果字符是可打印字符（包括字母、数字、标点符号等），但不是空格，则返回非零值，否则返回0。
7. `isprint(c)`: 检查字符是否是可打印字符。如果字符是可打印字符（包括字母、数字、标点符号等），则返回非零值，否则返回0。
8. `ispunct(c)`: 检查字符是否是标点符号。如果字符是标点符号（例如句点、逗号、感叹号等），则返回非零值，否则返回0。
9. `isspace(c)`: 检查字符是否是空白字符。如果字符是空白字符（例如空格、换行符、制表符等），则返回非零值，否则返回0。
10. `isupper(c)`: 检查字符是否是大写字母。如果字符是大写字母，则返回非零值，否则返回0。
11. `isxdigit(c)`: 检查字符是否是十六进制数字。如果字符是十六进制数字（0-9、A-F或a-f之间的任何字符），则返回非零值，否则返回0。





## 全局变量和局部变量



### 全局变量

存储在全局区，在整个代码周期里面都是固定存在的。

如果没有加 static 关键字，则该变量将会工作在整个工程中；如果加了 static 关键字，则该变量将会工作在本地 .c 文件中。

### 局部变量

存储在栈区中，在函数体内部定义，并不可以随处使用，只能在作用域中被使用。

由于局部屏蔽全局。所以可以同名，但是不建议。

## 预编译

预编译其实就是预处理

```c
#include
#define
#ifdef
#if
#else
#endif
```


