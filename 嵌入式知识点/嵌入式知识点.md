# 一、c语言

## 1. static 静态

### 1.1 static 作用

​	用static修饰局部变量：使其变为静态存储方式(静态数据区)，那么这个局部变量在函数执行完成之后不会被释放，而是继续保留在内存中。

​	用static修饰全局变量：使其只在本文件内部有效，而其他文件不可连接或引用该变量。

​	用static修饰函数：对函数的连接方式产生影响，使得函数只在本文件内部有效，对其他文件是不可见的

### 1.2 **static全局变量**与**全局变量**区别

​	二者存储方式相同，都是 静态存储方式

​	非静态全局变量 作用域 整个程序

​	静态全局变量 作用域 定义该变量的源程序 

### 1.3 static函数与普通函数区别

​	静态函数的好处是，不用担心与其他文件的同名函数产生干扰，另外也是对函数本身的一种保护机制

​	非静态函数 作用域 整个程序

​	静态函数 作用域 定义该函数的源程序 

## 2. const

### 2.1 const 用法

​	用const修饰常量：定义时就初始化，以后不能更改。

​	用const修饰形参：func(const int a){};该形参在函数里不能改变。

​	用const修饰类成员函数：该函数对成员变量只能进行只读操作，就是const类成员函数是不能修改成员变量的数值的。



```c
const int a;
int const a; 			//前两个的作用是一样，a是一个常整型数。
const int *a; 			//第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。
int * const a; 			//第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。
int const * a const; 	//最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。

```

## 3. volatile

### 3.1 volatile 作用

​	用volatile修饰的变量说明是常变的，每次使用都要重新读取该变量在内存中的值

### 3.2 volatile 常见用法

​	并行设备的硬件寄存器（如：状态寄存器）

​	一个中断服务子程序中会访问到的非自动变量

​	多线程应用中被几个任务共享的变量



## 4. 内存分区

![](D:\stm103\my_note\嵌入式知识点\内存分区.jpg)

```c
int a0=1; 				//a0 ：全局初始化变量；生命周期为整个程序运行期间；作用域为所有文件；存储位置为data段。
static int a1;			//a1 ：全局静态未初始化变量；生命周期为整个程序运行期间；作用域为当前文件；储存位置为BSS段。
const static a2=0;		//a2 ：全局静态变量
extern int a3;			//a3 ：全局初始化变量；其他同a0。

void fun(void)
{
 int a4;				//a4 ：局部变量；生命周期为fun函数运行期间；作用域为fun函数内部；储存位置为栈。
 volatile int a5;		//a5 ：局部易变变量；
 return;
}

```



## 5. 指针





```c
int a；  			//一个整型数a
int *a;				//一个指向整型数的指针a	
int **a;			//一个指向指针的指针，a指向的指针指向一个整型数
int a[10];			//一个有10个整型的数组； a是指向数组首地址的指针
int *a [10];		//一个有10个指针的数组，该指针是指向一个整型数；
int a[10], *p=a;	//一个指向有10个整型数数组的指针
int (*a)(int)		//一个指向函数的指针，该函数有一个整型参数并返回一个整型数；
int( *a[10])(int)	//一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数

```



## 6. typeof()

typeof 不是c语言本身的关键词或运算符  是GCC的一个扩展

​	**用某种已有的变量或函数的类型去定义新的变量的类型**

通常用在宏定义中 eg：

```c
typeof(var)
typeof(a[0])
typeof(int *)
typeof(fun())
```

可以看到，`typeof()`中可以是任何有类型的东西，变量就是其本身的类型，函数是它返回值的类型。`typeof`一般用于声明变量，eg:

```c
typeof(a) var;
```

从语法上来说，所有可以出现基本类型关键词的地方都可以使用`typeof`，比如`sizeof(typeof(a))`这样的用法，虽然这里的`typeof`是多余的，不过它是符合语法的。

高级用法：

```c
int fun(int a);
typeof(fun) * fptr;    // int (*fptr)(int);

typeof(int *)a, b;     // int * a, * b;
typeof(int) * a, b;    // int * a, b;
```

可以看到，`typeof`还可以用来定义函数指针等，且`typeof(int *)a, b`是定义了两个指针变量。

`typeof()`是在编译时处理的，故**其中的表达式在运行时是不会被执行的**，比如`typeof(fun())`，`fun()`函数是不会被执行的，`typeof`只是在编译时分析得到了`fun()`的返回值.

`typeof`还有一些局限性，其中的变量是不能包含存储类说明符的，如`static`、`extern`这类都是不行的。


## 6. 运算符
### 6.1   '!'





------



# 二、通信接口

## 1. UART

### 1.1 工作原理

​	两个uart之间相互通信，将 并行数据转化为串行数据进行传输，需要两根通信线 Tx Rx 两个uart之间交叉相连 

​	Tx1 <----> Rx2

​	Rx1 <----> Tx1

![](D:\stm103\my_note\嵌入式知识点\uart连接图.png)

​	串口通信属于 异步通信 不需要时钟线同步信号。

​	会在数据包中添加 开始位 停止位

​	帧格式 ： 起始位 数据帧 校验位 停止位

### 1.2 优缺点

#### 	1.2.1 优点

​		仅需两根通讯线

​		异步通信，无需时钟信号

​		具有奇偶校验位，有纠错空间

​		只需要收发双方设定好 数据包的结构

#### 	1.2.2 缺点

​		数据帧最大为9位

​		不支持从属系统或多个系统

​		接受双方波特率要对应相等

## 2. SPI

### 2.1 工作原理

在SPI设备中，设备分为主机控制设备（通常是微控制器）和从机（通常是传感器，显示器和存储芯片）设备，从机从主机那获取指令。

**SPI信号线有四种：**

MOSI-信号线：主机输出，从机输入；
MISO-信号线：主机输入，从机输出；
SCLK-时钟信号；
SS/CS-片选信号；

### 2.2 通信步骤

1.主机输出时钟信号

![](D:\stm103\my_note\嵌入式知识点\spi通信步骤1.png)

2.主机拉低SS/CS引脚，激活从机

![](D:\stm103\my_note\嵌入式知识点\spi通信步骤2.png)

3.主机通过MOSI将数据发送给从机

![](D:\stm103\my_note\嵌入式知识点\spi通信步骤3.png)

4.如果需要相应，则从机通过MISO将数据返回给从机

![](D:\stm103\my_note\嵌入式知识点\spi通信步骤4.png)



### 2.3 优缺点

#### 2.3.1 优点

无起始位和停止位，因此数据可以持续传输不会中断；

数据传输速率快（比IIC快几乎两倍）；

独立的MISO、MOSI可以同时发送和接收数据。

#### 2.3.2 缺点

使用四根线（IIC使用两根线）

没有信号接收成功的确认（IIC由此功能）

没有任何形式的错误检查（UART中的奇偶校验位）

## 3. IIC

### 3.1 工作原理

串行通信协议，需要时钟同步信号并且由主机控制。

半双工通信，可以将多个从机连接到单个主机（如SPI），也可以多个主机控制一个或多个从机。

两根信号线 SDA–数据线 SCL–时钟线

IIC的数据传输是以多个msg的形式进行。

每个msg包括：从机二进制地址帧、以及一个或者多个数据帧、开始条件和停止条件，读/写位和数据帧之间的ACK/NACK位：

![](D:\stm103\my_note\嵌入式知识点\IICmsg格式.png)

![](D:\stm103\my_note\嵌入式知识点\IIC通信电平.png)

​		

**启动条件：当SCL为高电平时，SDA从高电平向低电平切换**

**停止条件：当SCL是高电平时，SDA由低电平向高电平切换**

### 3.2 通信步骤

1.在SCL线为高电平时，主机通过将SDA线从高电平切换到低电平来启动总线通信。
2.主机向总线发送要与之通信的从机的7位或10位地址，以及读/写位
3.每个从机将主机发送的地址与其自己的地址进行比较。如果地址匹配，则从机通过将SDA线拉低一位返回一个ACK位。如果主机的地址与从机的地址不匹配，则从机将SDA线拉高。
4.主机发送或接收数据帧；
5.传输完每个数据帧后，接收设备将另一个ACK位返回给发送方，以确认已成功接收到该帧；
6.随后主机将SCL切换为高电平，然后再将SDA切换为高电平，从而向从机发送停止条件。

### 3.3 优缺点

#### 3.3.1 优点

1.仅仅使用两根线
2.支持多个主机和从机
3.硬件比UART更简单

#### 3.3.2 缺点

1.数据传输比SPI慢
2.数据帧大小限制为8位



